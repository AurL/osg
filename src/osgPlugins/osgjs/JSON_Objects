/*  -*-c++-*- 
 *  Copyright (C) 2010 Cedric Pinson <cedric.pinson@plopbyte.net>
 */

#ifndef JSON_OBJECT
#define JSON_OBJECT

#include <osg/Matrix>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <osg/Array>
#include <osg/Light>
#include <osg/Notify>
#include <osg/PrimitiveSet>

#include <sstream>
#include <fstream>
#include <iostream>

struct Vec5
{
    float _v[5];
    Vec5() {}
    Vec5(float a0, float a1, float a2, float a3, float a4) {
        _v[0] = a0;
        _v[1] = a1;
        _v[2] = a2;
        _v[3] = a3;
        _v[4] = a4;
    };
    inline float& operator [] (int i) { return _v[i]; }
    inline float operator [] (int i) const { return _v[i]; }
};

struct JSONObjectBase : public osg::Referenced
{
    static int level;
    static std::string indent();
    virtual void write(std::ostream& str) {}
};

template <class T> class JSONValue;

class JSONArray;
struct JSONObject : public JSONObjectBase
{
    typedef std::map<std::string, osg::ref_ptr<JSONObject> > JSONMap;
    typedef std::vector<std::string> OrderList;
    JSONMap _maps;
    JSONMap& getMaps() { return _maps; }
    void writeOrder(std::ostream& str, const OrderList& order);
    virtual void write(std::ostream& str);
    void addChild(const std::string& type, JSONObject* child);
    virtual JSONArray* asArray() { return 0; }
    template<class T> JSONValue<T>* asValue() {
        return dynamic_cast<JSONValue<T> * > ( this); 
    }

    JSONObject(const unsigned int id);
    JSONObject();
    void addUniqueID();
    unsigned int getUniqueID() const { return _uniqueID; }
    JSONObject* getShadowObject() { return new JSONObject(_uniqueID); }

    unsigned int _uniqueID;
    static unsigned int uniqueID;
};

JSONObject* createLight(osg::Light* light);

struct JSONNode : public JSONObject
{
    void write(std::ostream& str);
};

typedef JSONObject JSONStateSet;
typedef JSONObject JSONMaterial;
typedef JSONObject JSONLight;


struct JSONArray : public JSONObject
{
    typedef std::vector<osg::ref_ptr<JSONObject> > JSONList;
    JSONList _array;
    
    JSONArray(){}
    virtual void write(std::ostream& str);
    JSONList& getArray() { return _array; }
    JSONArray* asArray() { return this; }
};

struct JSONKeyframes : public JSONArray
{
    virtual void write(std::ostream& str);
};


struct JSONVec3Array : public JSONArray
{
    JSONVec3Array() {}
    JSONVec3Array(const osg::Vec3&);
    virtual void write(std::ostream& str);
};

struct JSONVec4Array : public JSONVec3Array
{
    JSONVec4Array(const osg::Vec4&);
};

struct JSONVec5Array : public JSONVec3Array
{
    JSONVec5Array(const Vec5&);
};

struct JSONVec2Array : public JSONVec3Array
{
    JSONVec2Array(const osg::Vec2&);
};

template <class T> 
struct JSONValue : public JSONObject
{
    T _value;
    JSONValue(const T& v) {
        _value = v;
    }
    T& getValue() { return _value; }
    virtual void write(std::ostream& str) {
        str << _value ;
    }

};

template <>
struct JSONValue<double> : public JSONObject
{
    double _value;
    JSONValue(const double& v) {
        _value = v;
    }
    void write(std::ostream& str) {
        if (osg::isNaN(_value)) {
            _value = 0.0;
        }
        str << _value;
    }
};

template <>
struct JSONValue<std::string> : public JSONObject
{
    std::string _value;
    JSONValue(const std::string& v) {
        _value = v;
        // replace invalid \ by /
        std::replace(_value.begin(), _value.end(), '\\','/');
    }
    void write(std::ostream& str) {
        str << '"' << _value  << '"';
    }
};


struct JSONMatrix : public JSONArray
{
    JSONMatrix(const osg::Matrix& matrix) {
        for (int i = 0; i < 16; i++) {
            _array.push_back(new JSONValue<double>(matrix.ptr()[i]));
        }
    }
    void write(std::ostream& str)
    {
        str << "[ ";
        for (unsigned int i = 0; i < _array.size(); i++) {
            _array[i]->write(str);
            if (i != _array.size() -1)
                str << ", ";
        }
        str <<  " ]";
    }
};



struct JSONVertexArray : public JSONArray
{
    osg::ref_ptr<const osg::Array> _arrayData;
    std::string _baseName;
    bool _externalBinaryArray;

    void setBaseName(const std::string& basename) { _baseName = basename; }
    void useExternalBinaryArray(bool t) { _externalBinaryArray = t; }
    unsigned int writeData(const osg::Array* array, const std::string& filename) 
    {
        std::ofstream myfile;
        myfile.open(filename.c_str(), std::ios::binary );
        const char* b = static_cast<const char*>(array->getDataPointer());
        myfile.write(b, array->getTotalDataSize());
        unsigned int fsize = myfile.tellp(); 
        myfile.close();
        return fsize;
    }

    template <class T> void writeInlineArray(std::ostream& str, unsigned int size, const T* array) {
        str << JSONObjectBase::indent() << "\"Elements\": [ " << array[0];
        for (unsigned int i = 1; i < size; i++) {
            T v = array[i];
            str << ", " <<v;
        }
        str << " ],";
    }

    template <class T> void writeInlineArrayReal(std::ostream& str, unsigned int size, const T* array) {
        str << JSONObjectBase::indent() << "\"Elements\": [ " << array[0];
        for (unsigned int i = 1; i < size; i++) {
            float v = array[i];
            if (osg::isNaN(v))
                v = 0;
            str << ", " <<v;
        }
        str << " ]," << std::endl;
    }

    void write(std::ostream& str)
    {
        addUniqueID();

        std::stringstream url;
        url << _baseName << "_" << _uniqueID << ".bin";

        std::string type;
        
        osg::ref_ptr<const osg::Array> array = _arrayData;

        switch (array->getType()) {
        case osg::Array::FloatArrayType:
        case osg::Array::Vec2ArrayType:
        case osg::Array::Vec3ArrayType:
        case osg::Array::Vec4ArrayType:
            type = "Float32Array";
            break;
        case osg::Array::Vec4ubArrayType:
        {
            osg::ref_ptr<osg::Vec4Array> converted = new osg::Vec4Array;
            converted->reserve(array->getNumElements());
            
            const osg::Vec4ubArray* a = dynamic_cast<const osg::Vec4ubArray*>(array.get());
             for (unsigned int i = 0; i < a->getNumElements(); ++i) {
                 converted->push_back(osg::Vec4( (*a)[i][0]/255.0,
                                                 (*a)[i][1]/255.0,
                                                 (*a)[i][2]/255.0,
                                                 (*a)[i][3]/255.0));
             }
             array = converted;
             type = "Float32Array";
        }
        break;
        case osg::Array::UShortArrayType:
            type = "Uint16Array";
            break;
        default:
            osg::notify(osg::WARN) << "Array of type " << array->getType() << " not supported" << std::endl;
            break;
        }

        str << "{ " << std::endl;
        JSONObjectBase::level++;
        str << JSONObjectBase::indent() << "\"" << type << "\"" << ": { " << std::endl;
        JSONObjectBase::level++;
        if (_externalBinaryArray) {
            str << JSONObjectBase::indent() << "\"File\": \"" << url.str() << "\","<< std::endl;
        } else {
            if (array->getNumElements() == 0) {
                str << JSONObjectBase::indent() << "\"Elements\": [ ],";

            } else {

                switch (array->getType()) {
                case osg::Array::FloatArrayType:
                case osg::Array::Vec2ArrayType:
                case osg::Array::Vec3ArrayType:
                case osg::Array::Vec4ArrayType:
                {
                    const float* a = static_cast<const float*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArrayReal<float>(str, size, a);
                }
                break;
                case osg::Array::DoubleArrayType:
                case osg::Array::Vec2dArrayType:
                case osg::Array::Vec3dArrayType:
                case osg::Array::Vec4dArrayType:
                {
                    const double* a = static_cast<const double*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArrayReal<double>(str, size, a);
                }
                break;
                case osg::Array::ByteArrayType:
                case osg::Array::Vec2bArrayType:
                case osg::Array::Vec3bArrayType:
                case osg::Array::Vec4bArrayType:
                {
                    const char* a = static_cast<const char*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<char>(str, size, a);
                }
                break;
                case osg::Array::UByteArrayType:
                case osg::Array::Vec4ubArrayType:
                {
                    const unsigned char* a = static_cast<const unsigned char*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<unsigned char>(str, size, a);
                }
                break;
                case osg::Array::UShortArrayType:
                {
                    const unsigned short* a = static_cast<const unsigned short*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<unsigned short>(str, size, a);
                }
                break;
                case osg::Array::ShortArrayType:
                case osg::Array::Vec2sArrayType:
                case osg::Array::Vec3sArrayType:
                case osg::Array::Vec4sArrayType:
                {
                    const short* a = static_cast<const short*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<short>(str, size, a);
                }
                break;
                case osg::Array::IntArrayType:
                {
                    const int* a = static_cast<const int*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<int>(str, size, a);
                }
                break;
                case osg::Array::UIntArrayType:
                {
                    const unsigned int* a = static_cast<const unsigned int*>(array->getDataPointer());
                    unsigned int size = array->getNumElements() * array->getDataSize();
                    writeInlineArray<unsigned int>(str, size, a);
                }
                break;

                }
            }
        }
        str << JSONObjectBase::indent() << "\"Size\": " << array->getNumElements() << std::endl;
        JSONObjectBase::level--;
        str << JSONObjectBase::indent() << "}" << std::endl;
        JSONObjectBase::level--;

        if (_externalBinaryArray) {
            unsigned int size = writeData(array.get(), url.str());
            std::stringstream b;
            osg::notify(osg::NOTICE) << "TypedArray " << type << " " << url.str() << " ";
            if (size/1024.0 < 1.0) {
                osg::notify(osg::NOTICE) << size << " bytes" << std::endl;
            } else if (size/(1024.0*1024.0) < 1.0) { 
                osg::notify(osg::NOTICE) << size/1024.0 << " kb" << std::endl;
            } else {
                osg::notify(osg::NOTICE) << size/(1024.0*1024.0) << " mb" << std::endl;
            }
        }
        str << JSONObjectBase::indent() << "}";

    }


    JSONVertexArray() {
        _externalBinaryArray = false;
    }
    JSONVertexArray(const osg::Array* array) {
        _arrayData = array;
        _externalBinaryArray = false;
    }
};

struct JSONBufferArray : public JSONObject
{
    JSONBufferArray() {}
    JSONBufferArray(const osg::Array* array, 
                    const std::string& basename,
                    bool useExternalBinaryArray)
        {
        JSONVertexArray* b = new JSONVertexArray(array);
        b->setBaseName(basename);
        b->useExternalBinaryArray(useExternalBinaryArray);
        getMaps()["Array"] = b;
        getMaps()["ItemSize"] = new JSONValue<int>(array->getDataSize());
        getMaps()["Type"] = new JSONValue<std::string>("ARRAY_BUFFER"); //0x8892);
    }
};


JSONObject* getDrawMode(GLenum mode);

struct JSONDrawArray : public JSONObject
{
    JSONDrawArray(osg::DrawArrays& array);
};

struct JSONDrawArrayLengths : public JSONObject
{
    JSONDrawArrayLengths(osg::DrawArrayLengths& array);
};


template <class T>
struct JSONDrawElements : public JSONObject
{
    JSONDrawElements(T& array, 
                     const std::string& baseName,
                     bool useExternalBinaryArray) {

        osg::ref_ptr<osg::UShortArray> idxArray;
        if (array.getMode() == GL_QUADS) {
            int size = array.getNumIndices();
            idxArray = new osg::UShortArray(size);
            unsigned int idx = 0;
            for (int i = 0; i < size/4; ++i) {
                (*idxArray)[idx++] = array.index(i*4 + 0);
                (*idxArray)[idx++] = array.index(i*4 + 1);
                (*idxArray)[idx++] = array.index(i*4 + 3);

                (*idxArray)[idx++] = array.index(i*4 + 1);
                (*idxArray)[idx++] = array.index(i*4 + 2);
                (*idxArray)[idx++] = array.index(i*4 + 3);
            }
            getMaps()["Mode"] = getDrawMode(osg::PrimitiveSet::TRIANGLES);
        } else {
            idxArray = new osg::UShortArray(array.size());
            int size = array.getNumIndices();
            for (int i = 0; i < size; ++i) {
                (*idxArray)[i] = array[i];
            }
            getMaps()["Mode"] = getDrawMode(array.getMode());
        }

        JSONBufferArray* buf = new JSONBufferArray(idxArray.get(), baseName, useExternalBinaryArray);
        buf->getMaps()["Type"] = new JSONValue<std::string>("ELEMENT_ARRAY_BUFFER");
        getMaps()["Indices"] = buf;
    }

};

#endif
