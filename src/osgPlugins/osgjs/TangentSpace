/* -*-c++-*- */
#ifndef TANGENT_SPACE_VISITOR_H
#define TANGENT_SPACE_VISITOR_H
#include <osgUtil/TangentSpaceGenerator>

#define TANGENT_ATTRIBUTE_INDEX 20
#define BITANGENT_ATTRIBUTE_INDEX 21

struct TangentSpaceVisitor : osg::NodeVisitor
{
public:
    int _textureUnit;
    typedef std::map<osg::Geometry*, bool> GeometryProcessed;
    GeometryProcessed _geometryProcessed;

public:
    TangentSpaceVisitor(int textureUnit = 0) : osg::NodeVisitor(TRAVERSE_ALL_CHILDREN){
        _textureUnit = textureUnit;
    }

    void apply(osg::Geode& geode) {
        for (unsigned int i = 0; i < geode.getNumDrawables(); i++) {
            apply(*geode.getDrawable(i));
        }
    }

    void apply(osg::Drawable& drw) {
        osg::Geometry* geom = dynamic_cast<osg::Geometry*>(&drw);

        // already processed
        if (_geometryProcessed.find(geom) != _geometryProcessed.end()) {
            return;
        }
        if (geom) {

            osg::ref_ptr<osgUtil::TangentSpaceGenerator> generator = new osgUtil::TangentSpaceGenerator;
            generator->generate(geom, _textureUnit);
            if (generator->getNormalArray()) {
                geom->setNormalArray(generator->getNormalArray());
            }
            if (generator->getTangentArray()) {
                geom->setVertexAttribArray(TANGENT_ATTRIBUTE_INDEX, generator->getTangentArray());
            }
            if (generator->getBinormalArray()) {
                geom->setVertexAttribArray(BITANGENT_ATTRIBUTE_INDEX, generator->getBinormalArray());
            }
            _geometryProcessed[geom] = true;
        }
    }
};

#endif
